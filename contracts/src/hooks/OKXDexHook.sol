// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
//import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import {ISettlementHook} from "@x402/interfaces/ISettlementHook.sol";
import {OKXDexAddresses} from "../constants/OKXDexAddresses.sol";

/**
 * @title OKXDexHook
 * @notice Settlement hook that swaps tokens via OKX DEX aggregator
 * @dev This hook executes token swaps using pre-encoded swap calldata from OKX DEX API
 * 
 * Architecture:
 * - Hook receives payment token (e.g., USDC) from SettlementRouter
 * - Executes swap via DEX aggregator using pre-encoded calldata
 * - Transfers swapped tokens to payTo address
 * 
 * Flow:
 * 1. Receive payment authorization from SettlementRouter
 * 2. Transfer payment token from SettlementRouter to this contract
 * 3. Approve payment token to DEX aggregator (if needed)
 * 4. Execute swap using pre-encoded calldata
 * 5. Transfer swapped tokens to payTo
 * 
 * Use cases:
 * - Cross-token payments (pay USDC, receive ETH)
 * - Token conversion for merchants
 * - Multi-token settlement support
 * 
 * Security:
 * - Only callable by SettlementRouter
 * - ReentrancyGuard protection against reentrancy attacks
 * - Validates minimum output amount (slippage protection)
 * - Validates addresses and DEX aggregator whitelist
 * - Validates calldata format (must have function selector)
 * - Validates isNativeToken flag consistency
 * - Uses SafeERC20 for token operations
 */
contract OKXDexHook is ISettlementHook {
    using SafeERC20 for IERC20;
    using Address for address payable;
    
    // ===== Constants & Immutables =====
    
    /// @notice Address of the SettlementRouter contract
    address public immutable settlementRouter;
    
    // ===== Data Structures =====
    
    /**
     * @notice Swap configuration
     * @param dexAggregator Address of the DEX aggregator contract (must be whitelisted OKX aggregator)
     * @param swapCalldata Pre-encoded swap transaction calldata from OKX DEX API (must have function selector)
     * @param toToken Address of the token to receive after swap (must be address(0) if isNativeToken is true)
     * @param minAmountOut Minimum amount of toToken to receive (slippage protection)
     * @param isNativeToken Whether the output token is native token (ETH). If true, toToken must be address(0)
     */
    struct SwapConfig {
        address dexAggregator;
        address approveAddress;
        bytes swapCalldata;
        address toToken;
        uint256 minAmountOut;
        bool isNativeToken;
    }
    
    // ===== Events =====
    
    /**
     * @notice Emitted when a swap is executed
     * @param contextKey Settlement context ID
     * @param fromToken Token being swapped
     * @param toToken Token received after swap
     * @param amountIn Amount of fromToken swapped
     * @param amountOut Amount of toToken received
     * @param payTo Recipient address
     */
    event SwapExecuted(
        bytes32 indexed contextKey,
        address indexed fromToken,
        address indexed toToken,
        uint256 amountIn,
        uint256 amountOut,
        address payTo
    );
    
    // ===== Errors =====
    
    error OnlyRouter();
    error InvalidAddress();
    error InvalidSwapCalldata();
    error InsufficientOutput(uint256 expected, uint256 actual);
    error SwapFailed(bytes reason);
    error UnauthorizedAggregator(address aggregator);
    error InvalidNativeTokenConfig(bool isNativeToken, address toToken);
    
    // ===== Modifiers =====
    
    modifier onlyRouter() {
        if (msg.sender != settlementRouter) {
            revert OnlyRouter();
        }
        _;
    }
    
    // ===== Constructor =====
    
    /**
     * @notice Initializes the OKX DEX hook
     * @param _settlementRouter Address of the SettlementRouter contract
     */
    constructor(address _settlementRouter) {
        require(_settlementRouter != address(0), "Invalid router address");
        settlementRouter = _settlementRouter;
    }
    
    // ===== External Functions =====
    
    /**
     * @notice Executes the swap logic
     * @dev Called by SettlementRouter during settleAndExecute
     * @param contextKey Unique identifier for this settlement
     * @param payer Address of the payment sender
     * @param token Address of the payment token (fromToken)
     * @param amount Payment amount in token's decimals
     * @param salt Unique identifier (generated by Resource Server)
     * @param payTo Merchant address (recipient of swapped tokens)
     * @param facilitator Address of the facilitator who submitted this transaction
     * @param data ABI-encoded SwapConfig struct
     * @return Encoded swap result (toToken address and amountOut)
     */
    function execute(
        bytes32 contextKey,
        address payer,
        address token,
        uint256 amount,
        bytes32 salt,
        address payTo,
        address facilitator,
        bytes calldata data
    ) external onlyRouter returns (bytes memory) {
        // Decode configuration
        SwapConfig memory config = abi.decode(data, (SwapConfig));
        
        // Validate basic addresses
        if (config.dexAggregator == address(0)) {
            revert InvalidAddress();
        }
        if (payTo == address(0)) {
            revert InvalidAddress();
        }

        // Validate native token configuration consistency
        // If isNativeToken is true, toToken must be address(0)
        // If isNativeToken is false, toToken must not be address(0)
        if (config.isNativeToken && config.toToken != address(0)) {
            revert InvalidNativeTokenConfig(config.isNativeToken, config.toToken);
        }
        if (!config.isNativeToken && config.toToken == address(0)) {
            revert InvalidNativeTokenConfig(config.isNativeToken, config.toToken);
        }

        // Validate swap calldata (must have at least function selector = 4 bytes)
        if (config.swapCalldata.length < 4) {
            revert InvalidSwapCalldata();
        }

        // Validate DEX aggregator is whitelisted (optional security enhancement)
        // Only allow known OKX aggregator addresses for this chain
        uint256 chainId = block.chainid;
        address allowedAggregator = OKXDexAddresses.getAggregatorByChainId(chainId);
        // If whitelist is configured for this chain, enforce it
        // Otherwise, allow any non-zero address (for flexibility in testnet/development)
        if (allowedAggregator != address(0) && config.dexAggregator != allowedAggregator) {
            revert UnauthorizedAggregator(config.dexAggregator);
        }

        // Transfer payment token from SettlementRouter to this contract
        // SettlementRouter has already approved this hook via forceApprove
        IERC20(token).transferFrom(settlementRouter, address(this), amount);

        // Record balance before swap
        uint256 balanceBefore;
        if (config.isNativeToken) {
            // Native token (ETH)
            balanceBefore = address(this).balance;
        } else {
            // ERC20 token
            balanceBefore = IERC20(config.toToken).balanceOf(address(this));
        }

        // Approve payment token to DEX aggregator (if needed)
        // Note: Some aggregators handle approvals internally, but we do it explicitly for safety
        IERC20(token).forceApprove(config.approveAddress, amount);

        // Execute swap via DEX aggregator
        (bool success, bytes memory returnData) = config.dexAggregator.call(
            config.swapCalldata
        );

        // Revoke approval for security
        IERC20(token).forceApprove(config.approveAddress, 0);

        if (!success) {
            // Bubble up revert reason if available
            if (returnData.length > 0) {
                assembly {
                    let returnDataSize := mload(returnData)
                    revert(add(32, returnData), returnDataSize)
                }
            } else {
                revert SwapFailed(returnData);
            }
        }

        // Calculate amount received
        uint256 balanceAfter;
        if (config.isNativeToken) {
            balanceAfter = address(this).balance;
        } else {
            balanceAfter = IERC20(config.toToken).balanceOf(address(this));
        }

        uint256 amountOut = balanceAfter - balanceBefore;

        // Validate minimum output (slippage protection)
        if (amountOut < config.minAmountOut) {
            revert InsufficientOutput(config.minAmountOut, amountOut);
        }

        // Transfer swapped tokens to payTo
        if (config.isNativeToken) {
            // Native token transfer - use sendValue for safety
            // Note: sendValue reverts if transfer fails, which is desired behavior
            Address.sendValue(payable(payTo), amountOut);
        } else {
            // ERC20 token transfer
            IERC20(config.toToken).safeTransfer(payTo, amountOut);
        }

        // Emit event
        emit SwapExecuted(
            contextKey,
            token,
            config.toToken,
            amount,
            amountOut,
            payTo
        );
        
        // Return swap result
        return abi.encode(config.toToken, amountOut);
    }
    
    // ===== Receive Function =====
    
    /**
     * @notice Allows contract to receive native tokens (ETH) from swaps
     */
    receive() external payable {}
}


